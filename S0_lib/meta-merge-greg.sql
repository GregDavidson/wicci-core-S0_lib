-- * Header  -*-Mode: sql;-*-

-- ---> LYNN: See "LYNN" keyword below <---

--	PostgreSQL Metaprogramming Utilities Code for Merging Relations

-- ** Copyright

--	Copyright (c) 2013, J. Greg Davidson.
--	This code may be freely used by CreditLink Corporation
--	for their internal business needs but not redistributed
--	to third parties.

-- ** Depends

-- SELECT require_module('meta-more-code');

-- This module provides machinery for merging relations (sets of rows)
-- + from a remote database fork
-- + into local tables
-- + while renumbering id fields

-- * basic pieces

-- consider doing all this in a separate Schema!

CREATE TABLE IF NOT EXISTS my_merge_schemas (
	schema_oid oid
);

DELETE FROM my_merge_schemas;

DO $$
DECLARE
	schema_name text;
	schema_names text[] := ARRAY['foo', 'bar']; -- <--- LYNN: List your schemas here!!!
	schema_oid oid;
BEGIN
	 FOREACH schema_name IN ARRAY schema_names LOOP
		SELECT INTO schema_oid oid FROM pg_namespace
		WHERE nspname = schema_name;					-- or ILIKE ??
		IF NOT FOUND THEN
			RAISE NOTICE 'SKIPPING NON-EXISTENT SCHEMA %', schema_name;
	  ELSE
			INSERT INTO my_merge_schemas VALUES (schema_oid);
		END IF;
  END LOOP;
END
$$;

CREATE OR REPLACE VIEW table_field_refs_table_field AS
SELECT
  c0.oid::regclass AS class0, a0.attnum AS col0, a0.attname AS field0,
  c1.oid::regclass AS class1, a1.attnum AS col1, a1.attname AS field1
FROM
  pg_constraint cn,
  pg_class c0, pg_attribute a0,
	pg_class c1, pg_attribute a1
WHERE c1.relnamespace IN (SELECT schema_oid FROM my_merge_schemas)
AND cn.contype = 'f'
AND c0.oid = cn.conrelid AND c0.oid = a0.attrelid AND a0.attnum = SOME(cn.conkey)
AND c1.oid = cn.confrelid AND c1.oid = a1.attrelid AND a1.attnum = SOME(cn.confkey);

TABLE table_field_refs_table_field;

CREATE OR REPLACE VIEW table_field_sequence AS
SELECT
  c.oid::regclass AS "table", d.objsubid AS "col",
  a.attname AS "field", s.oid::regclass AS "sequence"
FROM pg_depend d, pg_class c, pg_class s, pg_attribute a
WHERE c.relnamespace IN (SELECT schema_oid FROM my_merge_schemas)
AND d.refobjid = c.oid AND d.objid = s.oid
AND c.relkind = 'r' AND s.relkind = 'S'
AND a.attrelid = c.oid AND a.attnum = d.refobjsubid;

TABLE table_field_sequence;

CREATE OR REPLACE FUNCTION blink_query_rows(
  conn text, target regclass, wher text
) RETURNS text AS $$
  SELECT dblink_send_query(
    $1, $2, 'SELECT * FROM ' || ns.nsname || '.' || $3 || ' WHERE ' || $4
  ) FROM pg_class c, pg_namespace ns
	WHERE c.oid = $3 AND c.namespace = ns.oid
END
$$ LANGUAGE sql;

COMMENT ON FUNCTION 
blink_query_rows(conn text, target regclass, wher text)
IS '
  Send a query to the remote server
	to fetch rows of target table satisfying where constraint.
	You can fetch Bthe data using code calling dblink_get_result
	which might be generated by FUNCTION blink_insert_result_rows_text
';

CREATE OR REPLACE FUNCTION blink_insert_result_rows_text(
  conn text, target regclass
) RETURNS text AS $$
  SELECT 'INSERT INTO ' || $2 || '(' ||
	array_to_string( ARRAY(
	  SELECT (
		  SELECT quote_ident(attname)
		  FROM pg_attribute WHERE attrelid = $2 AND attnum = n
	  ) FROM generate_series(1, c.relnatts) n
	),		' ,'  ) ||	')' || E'\n' ||
	'SELECT * FROM dblink_get_result(' || $1 ||
	') AS foo(' || array_to_string( ARRAY(
	  SELECT (
		  SELECT quote_ident(attname) || ' ' || quote_ident(atttypid::regtype::text)
		  FROM pg_attribute WHERE attrelid = $2 AND attnum = n
	  ) FROM generate_series(1, c.relnatts) n
	),		','  ) || ')'
  FROM pg_class c WHERE c.oid = $2
$$ LANGUAGE sql;

COMMENT ON FUNCTION 
blink_insert_result_rows_text(conn text, target regclass)
IS '
	Generate the code which will result in inserting rows
	generated by an earlier blink_query_rows call
	with the same target table into the LOCAL target.
	Assumes (1) no other dblink_send_query calls intervene,
	(2) the schema (namespace) and the definition of the remote
	table is the same (or a superset) of the local table with
	the given target.
';

SELECT blink_insert_result_rows_text('foo', 'my_merge_schemas');

