-- * Header  -*-Mode: sql;-*-
\ir settings.sql
SELECT set_file('meta-code.sql', '$Id');

--	PostgreSQL Metaprogramming Utilities Code

-- ** Copyright

--	Copyright (c) 2005 - 2012, J. Greg Davidson.
--	This code may be freely used by CreditLink Corporation
--	for their internal business needs but not redistributed
--	to third parties.

-- ** Depends

-- SELECT require_module('modules-code');

-- This module provides machinery for creating PostgreSQL
-- entities from specifications.  Currently supports the
-- creation of tables and functions with most features.

-- * a few handy functions first

CREATE OR REPLACE
FUNCTION enum_syntax(ANYENUM) RETURNS text AS $$
	SELECT upper(enum_text($1))
$$ LANGUAGE sql;

COMMENT ON FUNCTION enum_syntax(ANYENUM) IS
'A bit of a kludge: The element is expected to be an enum
value representing a bit of sql keyword syntax.  The enum
value is converted to upper case text with any prefix and
trailing underscores removed and any remaining underscores
turned into spaces.';

CREATE OR REPLACE
FUNCTION meta_procedure_oid(text) RETURNS regprocedure AS $$
DECLARE
	_oid regprocedure;
BEGIN
	BEGIN
		EXECUTE 'SELECT CAST($1 AS regprocedure)' INTO _oid USING $1;
	EXCEPTION
		WHEN syntax_error_or_access_rule_violation THEN
			RETURN NULL;
	END;
	RETURN _oid;
END
$$ LANGUAGE plpgsql;

CREATE OR REPLACE
FUNCTION meta_type_oid(text) RETURNS regtype AS $$
DECLARE
	_oid regtype;
BEGIN
	BEGIN
		EXECUTE 'SELECT CAST($1 AS regtype)' INTO _oid USING $1;
	EXCEPTION
		WHEN syntax_error_or_access_rule_violation THEN
			RETURN NULL;
	END;
	RETURN _oid;
END
$$ LANGUAGE plpgsql;

CREATE OR REPLACE
FUNCTION meta_class_oid(text) RETURNS regclass AS $$
DECLARE
	_oid regclass;
BEGIN
	BEGIN
		EXECUTE 'SELECT CAST($1 AS regclass)' INTO _oid USING $1;
	EXCEPTION
		WHEN syntax_error_or_access_rule_violation THEN
			RETURN NULL;
	END;
	RETURN _oid;
END
$$ LANGUAGE plpgsql;

CREATE OR REPLACE
FUNCTION drop_entity(meta_entities, text) RETURNS boolean AS $$
DECLARE
	_result bool;
	this regprocedure := 'drop_entity(meta_entities, text)';
BEGIN
	BEGIN
		_result := meta_execute(
			this, 'DROP', enum_syntax($1), $2, 'CASCADE'
		);
	EXCEPTION
		WHEN syntax_error_or_access_rule_violation THEN
			RETURN false;							-- nothing to drop!
	END;
	RETURN true;									-- found it and dropped it!
END
$$ LANGUAGE plpgsql;

CREATE OR REPLACE
FUNCTION array_regtype(regtype) RETURNS regtype AS $$
	SELECT ($1::text || '[]')::regtype
$$ LANGUAGE sql IMMUTABLE;

CREATE OR REPLACE
FUNCTION regproc_name(regprocedure) RETURNS text AS $$
	SELECT $1::regproc::text
$$ LANGUAGE sql IMMUTABLE;

-- ** make nice lists and call forms

CREATE OR REPLACE
FUNCTION call_proc_text(regprocedure, VARIADIC text[] = '{}')
RETURNS text AS $$
	SELECT regproc_name($1) || '(' || array_to_string($2, ',') || ')'
$$ LANGUAGE sql IMMUTABLE;

CREATE OR REPLACE FUNCTION list_text_indent(
	_space text, _more text = ' ', _nl text = E'\n'
) RETURNS text AS $$
	SELECT CASE
		WHEN $1 IS NULL THEN $2
		WHEN $1 = '' THEN $2
		ELSE $3 || $1 || $2
	END
$$ LANGUAGE sql IMMUTABLE;

CREATE OR REPLACE FUNCTION try_list_nonnull_texts(
	items TEXT[], indent text = ''
) RETURNS text AS $$
	SELECT '(' || space
		|| array_to_string($1, ',' || space)
		|| list_text_indent($2, '') || ')'
	FROM list_text_indent($2) space
$$ LANGUAGE sql STRICT IMMUTABLE;

CREATE OR REPLACE FUNCTION try_list_texts(
	items TEXT[], indent text = ''
) RETURNS text AS $$
	SELECT try_list_nonnull_texts($1, $2)
	WHERE array_has_no_nulls($1)
$$ LANGUAGE sql STRICT IMMUTABLE;

CREATE OR REPLACE FUNCTION list_nonnull_texts(
	items TEXT[], indent text = ''
) RETURNS text AS $$
	SELECT non_null(
		try_list_nonnull_texts($1, $2), 'list_nonnull_texts(TEXT[], text)'
	)
$$ LANGUAGE sql IMMUTABLE;
COMMENT ON FUNCTION list_nonnull_texts(TEXT[], text) IS
'List the non-null elements of the array enclosed in parentheses,
separated by commas and fancy whitespace generated by
list_text_indent.';

CREATE OR REPLACE FUNCTION list_texts(
	items TEXT[], indent text = ''
) RETURNS text AS $$
	SELECT non_null(
		try_list_texts($1, $2), 'list_texts(TEXT[], text)'
	)
$$ LANGUAGE sql IMMUTABLE;
COMMENT ON FUNCTION list_texts(TEXT[], text) IS
'List the elements of the array enclosed in parentheses,
separated by commas and fancy whitespace generated by
list_text_indent.';

CREATE OR REPLACE FUNCTION call_texts(
	proc_name TEXT, args TEXT[], indent text = ''
) RETURNS text AS $$
	SELECT non_null($1, 'call_texts(TEXT, TEXT[], text)')
	|| list_texts($2, $3)
$$ LANGUAGE sql IMMUTABLE;

CREATE OR REPLACE
FUNCTION call_text(proc_name TEXT, VARIADIC args TEXT[])
RETURNS text AS $$
	SELECT call_texts($1, $2)
$$ LANGUAGE sql IMMUTABLE;

CREATE OR REPLACE FUNCTION in_call_text(
	indent TEXT, proc_name TEXT, VARIADIC args TEXT[]
) RETURNS text AS $$
	SELECT call_texts($2, $3, $1)
$$ LANGUAGE sql IMMUTABLE;

-- ** type conversion

CREATE OR REPLACE
FUNCTION try_reg_class_type(regclass) RETURNS regtype AS $$
	SELECT reltype FROM pg_class WHERE oid = $1
$$ LANGUAGE sql STRICT STABLE;

CREATE OR REPLACE
FUNCTION reg_class_type(regclass) RETURNS regtype AS $$
	SELECT non_null(try_reg_class_type($1),'reg_class_type(regclass)')
$$ LANGUAGE sql STABLE;
COMMENT ON FUNCTION reg_class_type(regclass) IS
'returns the type of a row of this class';

-- ** maybe functions

CREATE OR REPLACE
FUNCTION try_alt_text(text, text, text, text) RETURNS text AS $$
	SELECT COALESCE( $1 || $2 || $3,  $4  )
$$ LANGUAGE sql IMMUTABLE;

CREATE OR REPLACE
FUNCTION alt_text(text, text, text, text) RETURNS text AS $$
	SELECT non_null(
		try_alt_text($1,$2,$3,$4), 'alt_text(text, text, text, text)'
	)
$$ LANGUAGE sql IMMUTABLE;
COMMENT ON FUNCTION alt_text(text, text, text, text) IS
'alt_text(prefix, maybe text, suffix, alternative) -> coalesced text';

CREATE OR REPLACE
FUNCTION try_alt_text(text, text[], text, text, text)
RETURNS text AS $$
	SELECT CASE WHEN array_is_empty($2) THEN $5
				 ELSE $1 || array_to_string($2, $3) || $4
	END
$$ LANGUAGE sql IMMUTABLE;

CREATE OR REPLACE
FUNCTION alt_text(text, text[], text, text, text)
RETURNS text AS $$
	SELECT non_null(
		try_alt_text($1,$2,$3,$4,$5), 'alt_text(text, text[], text, text, text)'
	)
$$ LANGUAGE sql IMMUTABLE;
COMMENT ON FUNCTION alt_text(text, text[], text, text, text) IS
'alt_text(prefix, maybe text array, text to interpose, suffix,
alternative) -> coalesced array_to_string text;
individual NULL elements will be skipped - is this good???';

-- * comments

CREATE OR REPLACE
FUNCTION try_entity_text(meta_entities) RETURNS text AS $$
	SELECT name FROM meta_entity_traits WHERE entity = $1
$$ LANGUAGE sql STRICT IMMUTABLE;

CREATE OR REPLACE
FUNCTION entity_text(meta_entities) RETURNS text AS $$
	SELECT non_null(
		try_entity_text($1), 'entity_text(meta_entities)'
	)
$$ LANGUAGE sql IMMUTABLE;

-- could later do some formatting of the comment body,
-- allow markup, etc.
-- could create versions using the proper oid for the entity
CREATE OR REPLACE
FUNCTION try_comment_text(meta_entities, text, text)
RETURNS text AS $$
	SELECT E'\nCOMMENT ON ' || entity_text($1) || ' ' || $2
		|| E' IS\n' || quote_literal( NULLIF($3, '') ) || E';\n'
$$ LANGUAGE sql STRICT IMMUTABLE;

CREATE OR REPLACE
FUNCTION comment_text(meta_entities, text, text)
RETURNS text AS $$
	SELECT CASE
		WHEN $3 IS NULL THEN ''
		WHEN $3 = '' THEN ''
		ELSE non_null(
			try_comment_text($1, $2, $3),
			'comment_text(meta_entities, text, text)'
		)
	END
$$ LANGUAGE sql IMMUTABLE;
COMMENT ON FUNCTION comment_text(meta_entities, text, text) IS
'comment_text(entity kind, entity name, comment) -->
text for creating a comment on the given entity';

SELECT test_func(
	'comment_text(meta_entities, text, text)',
	comment_text(
		'meta__table',
		'dining_room',
		'a good place to eat'
	), $$
COMMENT ON TABLE dining_room IS
'a good place to eat';
$$ );

SELECT test_func(
	'comment_text(meta_entities, text, text)',
	comment_text(
		'meta__table',
		'meta_entities_traits',
		'a few properties of some PostgreSQL entities'
	), $$
COMMENT ON TABLE meta_entities_traits IS
'a few properties of some PostgreSQL entities';
$$ );

-- create_comment(*): a family of convenience functions

-- return boolean instead???
CREATE OR REPLACE FUNCTION create_comment(
	meta_entities, text, text
) RETURNS text AS $$
DECLARE
	entity_str TEXT := entity_text($1);
	comment_str TEXT := try_comment_text($1, $2, $3);
	this regprocedure := 'create_comment(meta_entities, text, text)';
	_result bool :=  try_meta_execute( this, comment_str );
BEGIN
	RETURN entity_str || ' ' || $2 || E'\n\t'
		|| COALESCE( NULLIF( $3, ''), 'NO COMMENT!!');
END
$$ LANGUAGE plpgsql;

SELECT create_comment(
	'meta__function',			 -- kind of comment
	'create_comment(meta_entities, text, text)', -- function signature
	'creates comment in database'		 -- comment
);

CREATE OR REPLACE FUNCTION create_function_comment(
	regprocedure, text
) RETURNS text AS $$
	SELECT create_comment('meta__function', $1::text, $2)
$$ LANGUAGE sql;

SELECT create_function_comment(
	'create_function_comment(regprocedure, text)',
	'creates a comment on a function'
);

CREATE OR REPLACE
FUNCTION create_table_comment(regclass, text) RETURNS text AS $$
	SELECT create_comment('meta__table', $1::text, $2)
$$ LANGUAGE sql;

SELECT create_function_comment(
	'create_table_comment(regclass, text)',
	'creates a comment on a table'
);

CREATE OR REPLACE
FUNCTION comment_column(regclass, text, text) RETURNS text AS $$
	SELECT create_comment('meta__column', $1::text || '.' || $2, $3)
$$ LANGUAGE sql;

SELECT create_function_comment(
	'comment_column(regclass, text, text)',
	'creates a comment on a column'
);

CREATE OR REPLACE
FUNCTION create_type_comment(regtype, text) RETURNS text AS $$
	SELECT create_comment('meta__type', $1::text, $2)
$$ LANGUAGE sql;

SELECT create_function_comment(
	'create_type_comment(regtype, text)',
	'creates a comment on a type'
);

-- * functions

-- ** function arguments

CREATE OR REPLACE FUNCTION meta_arg(
	_type regtype,
	_name maybe_arg_names=NULL,
	_default maybe_sql_exprs=NULL,
	_mode meta_argmodes = 'meta__in',
	_variadic boolean=false
) RETURNS meta_args AS $$
	SELECT ($2, $1, $3, $4, $5)::meta_args
$$ LANGUAGE sql;

CREATE OR REPLACE
FUNCTION try_arg_text(_args meta_args, show_names bool)
RETURNS text AS $$
	SELECT
		CASE WHEN $2 AND ($1).variadic_ THEN 'VARIADIC ' ELSE '' END ||
		CASE ($1).mode_
			WHEN 'meta__out' THEN 'OUT '
			WHEN 'meta__inout' THEN 'INOUT '
			ELSE ''
		END ||
		CASE
			WHEN NOT ($2 AND ($1).name_ IS NOT NULL) THEN ''
			ELSE ($1).name_::text || ' '
		END ||
		($1).type_
$$ LANGUAGE sql STRICT;

CREATE OR REPLACE
FUNCTION arg_text(_args meta_args, show_names bool)
RETURNS text AS $$
	SELECT non_null(
		try_arg_text($1, $2), 'arg_text(meta_args, bool)'
	)
$$ LANGUAGE sql IMMUTABLE;

/*
-- If these are ever needed, look carefully at their use cases
-- to see how they should deal with args which have no names
-- and then make sure that their names and comments properly
-- reflect that design!!

CREATE OR REPLACE
FUNCTION try_meta_args_name_set(meta_args[])
RETURNS SETOF arg_names AS $$
	SELECT (c).name_::arg_names FROM unnest($1) c
$$ LANGUAGE sql STRICT;

CREATE OR REPLACE
FUNCTION meta_args_name_set(meta_args[])
RETURNS SETOF arg_names AS $$
	SELECT non_null(
		try_meta_args_name_set($1),
		'meta_args_name_set(meta_args[])'
	)
$$ LANGUAGE sql;

CREATE OR REPLACE
FUNCTION try_meta_args_name_array(meta_args[])
RETURNS arg_name_arrays AS $$
	SELECT ARRAY(
		SELECT meta_args_name_set($1)::text
	)::arg_name_arrays
$$ LANGUAGE sql STRICT;

CREATE OR REPLACE
FUNCTION meta_args_name_array(meta_args[])
RETURNS arg_name_arrays AS $$
	SELECT non_null(
		try_meta_args_name_array($1),
		'meta_args_name_array(meta_args[])'
	)
$$ LANGUAGE sql;
*/

-- ** function languages

CREATE OR REPLACE
FUNCTION meta_lang_text(meta_langs)
RETURNS text AS $$
	SELECT non_null(
		enum_syntax($1) || ' ',
		'meta_lang_text(meta_langs)'
	)
$$ LANGUAGE sql IMMUTABLE;

/*
CREATE OR REPLACE
FUNCTION try_meta_lang_named_args(meta_langs)
RETURNS bool AS $$
	SELECT named_args FROM meta_langs_names
	WHERE lang = $1
$$ LANGUAGE sql STRICT IMMUTABLE;

CREATE OR REPLACE
FUNCTION meta_lang_named_args(meta_langs)
RETURNS bool AS $$
	SELECT non_null(
		try_meta_lang_named_args($1),
		'meta_lang_named_args(meta_langs)'
	)
$$ LANGUAGE sql IMMUTABLE;
*/

CREATE OR REPLACE
FUNCTION meta_lang_named_args(meta_langs)
RETURNS bool AS $$
	SELECT true
$$ LANGUAGE sql IMMUTABLE;
COMMENT ON FUNCTION meta_lang_named_args(meta_langs)
IS 'now PostgreSQL allows named args for all languages in the
parameter list - but not necessarily in the body!';
	
-- ** function headers

-- policy on newlines could become more flexible (and tidy)
-- might require more arguments - is it worth it???
CREATE OR REPLACE FUNCTION try_meta_func_head_text(
	text, meta_args[], show_arg_names bool = false
) RETURNS text AS $$
	SELECT $1 || '('
 || CASE WHEN $3 AND length(arg_string) > 60 THEN E'\n' ELSE '' END
 || arg_string
 || CASE WHEN $3 AND length(arg_string) > 60 THEN E'\n' ELSE '' END
 || ')'
	FROM array_to_string( ARRAY(
			 SELECT arg_text(meta_arg, $3)
			 FROM unnest($2) meta_arg
	), ', ' ) arg_string
$$ LANGUAGE sql STRICT;

CREATE OR REPLACE
FUNCTION meta_func_head_text(text, meta_args[], bool = false)
RETURNS text AS $$
	SELECT non_null(
		try_meta_func_head_text($1,$2,$3),
		'meta_func_head_text(text,meta_args[],bool)'
	)
$$ LANGUAGE sql;
COMMENT ON
FUNCTION meta_func_head_text(text, meta_args[], bool) IS
'(name, args, show arg names) -> name([arg name] arg_type, ...)';

CREATE OR REPLACE
FUNCTION try_meta_func_head_text(meta_funcs, bool)
RETURNS text AS $$
	SELECT meta_func_head_text( ($1).name_, ($1).args, $2 )
$$ LANGUAGE sql STRICT;

CREATE OR REPLACE
FUNCTION meta_func_head_text(meta_funcs, bool)
RETURNS text AS $$
	SELECT non_null(
		try_meta_func_head_text($1,$2),
		'meta_func_head_text(meta_funcs,bool)'
	)
$$ LANGUAGE sql;
COMMENT ON
FUNCTION meta_func_head_text(meta_funcs, bool) IS
'(func, show arg names) -> name([arg name] arg_type, ...)';

CREATE OR REPLACE
FUNCTION try_meta_func_head_text(meta_funcs)
RETURNS text AS $$
	SELECT meta_func_head_text(
		$1, meta_lang_named_args(($1).lang)
	)
$$ LANGUAGE sql STRICT;

CREATE OR REPLACE
FUNCTION meta_func_head_text(meta_funcs)
RETURNS text AS $$
	SELECT non_null(
		try_meta_func_head_text($1),
		'meta_func_head_text(meta_funcs)'
	)
$$ LANGUAGE sql;
COMMENT ON
FUNCTION meta_func_head_text(meta_funcs) IS
'func -> name([arg name] arg_type, ...)';

CREATE OR REPLACE
FUNCTION func_head_comment_text(regproc, meta_args[])
RETURNS text AS $$
	SELECT $1::text || '(' || arg_string || ')'
	FROM array_to_string( ARRAY(
			 SELECT (meta_arg).name_::text
			 FROM unnest($2) meta_arg
	), ', ' ) arg_string
$$ LANGUAGE sql;

-- ** constraints

CREATE OR REPLACE
FUNCTION is_table_constraint(abstract_constraints)
RETURNS boolean AS $$
	SELECT ($1).cnst_name IS NOT NULL
	OR array_length(from_column_name_array(($1).cols)) != 1
$$ LANGUAGE sql;

CREATE OR REPLACE FUNCTION is_column_constraint(
	column_names, abstract_constraints
) RETURNS boolean AS $$
	SELECT ($2).cols IS NOT NULL AND NOT is_table_constraint($2)
	AND array_length( from_column_name_array(($2).cols) ) = 1
	AND ($2).cols[1]::column_names = $1
$$ LANGUAGE sql;

CREATE OR REPLACE
FUNCTION constraint_name_text(text) RETURNS text AS $$
	SELECT alt_text( 'CONSTRAINT ', $1, '', '' )
$$ LANGUAGE sql;

CREATE OR REPLACE
FUNCTION constraint_name_text(abstract_constraints)
RETURNS text AS $$
	SELECT constraint_name_text( ($1).cnst_name )
$$ LANGUAGE sql;

-- * composite types and tables

CREATE OR REPLACE
FUNCTION column_name_array_text(column_name_arrays)
RETURNS text AS $$
	SELECT alt_text( '(' , $1 , ', ' , ')' , '' )
$$ LANGUAGE sql;

-- ** index constraints

CREATE OR REPLACE FUNCTION index_constraint(
	text, column_name_arrays,
	_defer constraint_deferrings = constraint_deferring(),
	_withs storage_vars_vals[] = '{}',
	_space maybe_table_spaces = NULL
) RETURNS index_constraints AS $$
	SELECT ROW(
		$1,				-- cnst_name
		CASE WHEN array_is_empty(from_column_name_array($2))
		THEN NULL::column_name_arrays
		ELSE $2 END,		-- cols
		CASE WHEN $3 IS NOT NULL THEN $3
		ELSE 'meta__not_deferrable' END, -- defer_
		CASE WHEN array_is_empty($4) THEN NULL::storage_vars_vals[]
		ELSE $4 END,		-- withs
		$5
	)::index_constraints
$$ LANGUAGE sql;

CREATE OR REPLACE
FUNCTION index_withs_text(storage_vars_vals[]) RETURNS text AS $$
	SELECT alt_text(
		' WITH',				-- prefix
		ARRAY(
			SELECT ' ' || (vv).var_name || alt_text('=', (vv).var_val, '', '')
			FROM unnest($1) vv
		),
		E'\n\t',			-- inbetween elements
		'',				-- suffix
		''				-- alternative if none
	)
$$ LANGUAGE sql;		-- IMMUTABLE

CREATE OR REPLACE
FUNCTION index_constraint_text(text, index_constraints)
RETURNS text AS $$
	SELECT
	constraint_name_text($2)
	|| ' ' || $1
	|| column_name_array_text( ($2).cols )
	|| index_withs_text( ($2).withs )
	|| alt_text( 'USING INDEX TABLESPACE ', ($2).space_::text, '', '' )
$$ LANGUAGE sql IMMUTABLE;
COMMENT ON FUNCTION index_constraint_text(
	text, index_constraints
) IS $$('UNIQUE'|'PRIMARY KEY', constraint) --> constraint def$$;

-- *** primary key index constraints

-- CREATE OR REPLACE
-- FUNCTION table_primary_key_texts(index_constraints)
-- RETURNS text[] AS $$
--   SELECT ARRAY(
--     SELECT index_constraint_text('PRIMARY KEY', $1)
--     WHERE is_table_constraint($1)
--   )
-- $$ LANGUAGE sql;
-- generates interesting bug; returns {NULL} rather than {}
-- which gives right result in an SQL context and 'PRIMARY KEY'
-- in a plpgsql context!!

CREATE OR REPLACE
FUNCTION table_primary_key_texts(index_constraints)
RETURNS text[] AS $$
	SELECT CASE WHEN $1 IS NULL THEN '{}'::text[]
			 WHEN NOT is_table_constraint($1) THEN '{}'::text[]
			 ELSE ARRAY[index_constraint_text('PRIMARY KEY', $1)]
	END
$$ LANGUAGE sql;
COMMENT ON
FUNCTION table_primary_key_texts(index_constraints) IS
'(constraint) --> empty array or singleton of multi-col primary key';

CREATE OR REPLACE FUNCTION try_column_primary_text(
	column_names, index_constraints
) RETURNS text AS $$
	SELECT CASE WHEN is_column_constraint($1, $2)
		THEN ' PRIMARY KEY'
		ELSE ''
	END
$$ LANGUAGE sql;
COMMENT ON FUNCTION try_column_primary_text(
column_names, index_constraints
) IS '''PRIMARY KEY'' if specified col is the indicated primary key';

-- *** unique index constraints

CREATE OR REPLACE
FUNCTION table_unique_constraint_texts(index_constraints[])
RETURNS text[] AS $$
	SELECT ARRAY(
		SELECT index_constraint_text('UNIQUE', c)
		FROM unnest($1) c
		WHERE is_table_constraint(c)
	)
$$ LANGUAGE sql;
COMMENT ON FUNCTION table_unique_constraint_texts(
	index_constraints[]
) IS
'(constraint) --> empty array or singleton of multi-col primary key';

CREATE OR REPLACE FUNCTION meta_column_unique_text(
	column_names, index_constraints[]
) RETURNS text AS $$
	SELECT CASE
		WHEN true = SOME(
			SELECT is_column_constraint($1, c)
			FROM unnest($2) c
		)
		THEN ' UNIQUE'
		ELSE ''
	END
$$ LANGUAGE sql;

CREATE OR REPLACE FUNCTION try_column_unique_text(
	column_names, index_constraints[]
) RETURNS text AS $$
	SELECT COALESCE(meta_column_unique_text($1, $2), '')
$$ LANGUAGE sql;
COMMENT ON FUNCTION try_column_unique_text(
	column_names, index_constraints[]
) IS '''UNIQUE'' if specified col is in one of the specified constraints';

-- ** foreign key constraints

CREATE OR REPLACE FUNCTION meta_foreign_key(
	text, column_name_arrays, constraint_deferrings,
	regclass, column_name_arrays, foreign_key_matchings,
	foreign_key_actions, foreign_key_actions
) RETURNS meta_foreign_keys AS $$
	SELECT ROW(
		$1, 			-- cnst_name
		CASE WHEN array_is_empty(from_column_name_array($2))
		THEN NULL::column_name_arrays
		ELSE $2 END,		-- cols
		CASE WHEN $3 IS NOT NULL THEN $3
		ELSE 'meta__not_deferrable' END, -- defer_
		$4,					   -- forn_table
		CASE WHEN array_is_empty(from_column_name_array($5))
		THEN NULL::column_name_arrays
		ELSE $5 END,		-- forn_cols
		CASE WHEN $6 IS NOT NULL THEN $6
		ELSE foreign_key_matching() END, -- matching
		CASE WHEN $7 IS NOT NULL THEN $7
		ELSE foreign_key_action() END, -- deleting
		CASE WHEN $8 IS NOT NULL THEN $8
		ELSE foreign_key_action() END -- updating
	)::meta_foreign_keys
$$ LANGUAGE sql;

CREATE OR REPLACE
FUNCTION foreign_key_matching_text(foreign_key_matchings)
RETURNS text AS $$
	SELECT CASE WHEN $1 IS NULL THEN ''
	ELSE CASE $1
		WHEN 'meta__match_simple' THEN ''
		WHEN 'meta__match_full' THEN ' MATCH FULL'
		WHEN 'meta__match_partial' THEN ' MATCH PARTIAL'
	END END
$$ LANGUAGE sql;

CREATE OR REPLACE
FUNCTION foreign_key_action_text(foreign_key_actions)
RETURNS text AS $$
	SELECT CASE WHEN $1 IS NULL THEN NULL
	ELSE CASE $1
		WHEN 'meta__error' THEN NULL
		WHEN 'meta__restrict' THEN 'RESTRICT'
		WHEN 'meta__cascade' THEN 'CASCADE'
		WHEN 'meta__set_null' THEN 'SET NULL'
		WHEN 'meta__set_default' THEN 'SET DEFAULT'
	END END
$$ LANGUAGE sql;

CREATE OR REPLACE
FUNCTION foreign_key_action_text(text, foreign_key_actions)
RETURNS text AS $$
	SELECT alt_text($1 || ' ', foreign_key_action_text($2), '', '')
$$ LANGUAGE sql;

CREATE OR REPLACE
FUNCTION constraint_deferring_text(constraint_deferrings)
RETURNS text AS $$
	SELECT CASE WHEN $1 IS NULL THEN ''
	ELSE CASE $1
		WHEN 'meta__not_deferrable' THEN ''
		WHEN 'meta__immediate' THEN ' DEFERRABLE'
		WHEN 'meta__deferred'
			THEN ' DEFERRABLE INITIALLY DEFERRED'
	END END
$$ LANGUAGE sql;

CREATE OR REPLACE FUNCTION foreign_key_references_text(
	meta_foreign_keys
) RETURNS text AS $$
	SELECT ' REFERENCES '
	|| ($1).forn_table::text
	|| column_name_array_text( ($1).forn_cols )
	|| foreign_key_matching_text( ($1).matching )
	|| foreign_key_action_text( 'ON DELETE', ($1).deleting )
	|| foreign_key_action_text( 'ON UPDATE', ($1).updating )
	|| constraint_deferring_text( ($1).defer_ )
$$ LANGUAGE sql IMMUTABLE;

CREATE OR REPLACE
FUNCTION foreign_key_text(meta_foreign_keys) RETURNS text AS $$
	SELECT constraint_name_text( ($1).cnst_name )
	|| ' FOREIGN KEY'
	|| column_name_array_text( ($1).cols )
	|| foreign_key_references_text($1)
$$ LANGUAGE sql IMMUTABLE;

-- ** check constraints

CREATE OR REPLACE FUNCTION check_constraint(
	text, column_name_arrays, constraint_deferrings, maybe_sql_exprs
) RETURNS check_constraints AS $$
	SELECT ROW(
		$1,				-- cnst_name
		CASE WHEN array_is_empty(from_column_name_array($2))
		THEN NULL::column_name_arrays
		ELSE $2 END,		-- cols
		CASE WHEN $3 IS NOT NULL THEN $3
		ELSE 'meta__not_deferrable' END, -- defer_
		$4					   -- check_
	)::check_constraints
$$ LANGUAGE sql;
COMMENT ON FUNCTION check_constraint(
	text, column_name_arrays, constraint_deferrings, maybe_sql_exprs
) IS
'We require the names of the columns referenced by the check
constraint in order to determine where to put the constraint in the
code.';

CREATE OR REPLACE
FUNCTION check_constraint_text(check_constraints)
RETURNS text AS $$
	SELECT constraint_name_text( ($1).cnst_name )
	|| ' CHECK(' || ($1).check_ || ')'
$$ LANGUAGE sql IMMUTABLE;

CREATE OR REPLACE
FUNCTION table_check_constraint_texts(check_constraints[])
RETURNS text[] AS $$
	SELECT ARRAY(
		SELECT constraint_name_text(c) FROM unnest($1) c
		WHERE is_table_constraint(c)
	)
$$ LANGUAGE sql;

CREATE OR REPLACE FUNCTION try_column_checks_text(
	column_names, check_constraints[]
) RETURNS text AS $$
	SELECT alt_text(
		'CHECK (',
		ARRAY(
			SELECT (cc).check_::text FROM unnest($2) cc
			WHERE is_column_constraint($1, cc)
		),
		') CHECK(',
		')',
		''
	)
$$ LANGUAGE sql;
COMMENT ON FUNCTION try_column_checks_text(
	column_names, check_constraints[]
) IS 'text of any check constraints involving only specified column';

-- ** TYPE meta_columns

CREATE OR REPLACE FUNCTION meta_column(
	column_names, regtype,
	_default maybe_sql_exprs = NULL,
	_not_null boolean = false,
	_ text = ''
) RETURNS meta_columns AS $$
	SELECT ($1, $2, $3, $4, $5)::meta_columns
$$ LANGUAGE sql;

CREATE OR REPLACE
FUNCTION meta_cols_name_set(meta_columns[])
RETURNS SETOF column_names AS $$
	SELECT (c).name_::column_names FROM unnest($1) c
$$ LANGUAGE sql;

CREATE OR REPLACE
FUNCTION meta_cols_name_array(meta_columns[])
RETURNS column_name_arrays AS $$
	SELECT ARRAY(
		SELECT meta_cols_name_set($1)::text
	)::column_name_arrays
$$ LANGUAGE sql;

-- Alas, PostgreSQL doesn't use the cast, even when explicit!!

-- DROP CAST IF EXISTS (meta_columns[] AS column_name_arrays);

-- CREATE CAST (meta_columns[] AS column_name_arrays)
-- WITH FUNCTION meta_cols_name_array(meta_columns[])
-- AS IMPLICIT;

CREATE OR REPLACE
FUNCTION meta_cols_type_set(meta_columns[])
RETURNS SETOF regtype AS $$
	SELECT (c).type_ FROM unnest($1) c
$$ LANGUAGE sql;

CREATE OR REPLACE
FUNCTION meta_cols_type_array(meta_columns[])
RETURNS regtype[] AS $$
	SELECT ARRAY(SELECT meta_cols_type_set($1))
$$ LANGUAGE sql;

CREATE OR REPLACE
FUNCTION meta_col_meta_arg(meta_columns)
RETURNS meta_args AS $$
	SELECT meta_arg( ($1).type_, ($1).name_ )
$$ LANGUAGE sql;

CREATE OR REPLACE
FUNCTION meta_cols_meta_arg_set(meta_columns[])
RETURNS SETOF meta_args AS $$
	SELECT meta_col_meta_arg(c) FROM unnest($1) c
$$ LANGUAGE sql;

CREATE OR REPLACE
FUNCTION meta_cols_meta_arg_array(meta_columns[])
RETURNS meta_args[] AS $$
	SELECT ARRAY(SELECT meta_cols_meta_arg_set($1))
$$ LANGUAGE sql;

CREATE OR REPLACE
FUNCTION primary_meta_column_array(regclass)
RETURNS meta_columns[] AS $$
	SELECT ARRAY(
		SELECT meta_column(attname::column_names, atttypid::regtype)
		FROM pg_attribute, pg_constraint
		WHERE attnum = SOME(conkey) AND attrelid = conrelid
			AND contype='p' AND  attrelid = $1
	)
$$ LANGUAGE sql;

CREATE OR REPLACE
FUNCTION meta_cols_primary_key(meta_columns[])
RETURNS index_constraints AS $$
	SELECT index_constraint(
		NULL::text, meta_cols_name_array($1), constraint_deferring()
	)
$$ LANGUAGE sql;

CREATE OR REPLACE
FUNCTION meta_cols_unique_key(meta_columns[])
RETURNS index_constraints AS $$
	SELECT index_constraint(NULL::text, meta_cols_name_array($1))
$$ LANGUAGE sql;

CREATE OR REPLACE FUNCTION meta_cols_forn_key(
	column_name_arrays, regclass, column_name_arrays
) RETURNS meta_foreign_keys AS $$
	SELECT meta_foreign_key(
		NULL::text,
		$1,				-- our columns
		constraint_deferring(),
		$2,				-- the foreign table
		$3,				-- the foreign columns
		foreign_key_matching(),
		foreign_key_action(),
		foreign_key_action()
	)
$$ LANGUAGE sql;

CREATE OR REPLACE
FUNCTION get_primary_forn_keys(regclass)
RETURNS meta_foreign_keys AS $$
	SELECT meta_cols_forn_key(colms, $1, colms)
FROM meta_cols_name_array(primary_meta_column_array($1)) colms
$$ LANGUAGE sql;

CREATE OR REPLACE FUNCTION same_forn_keys_cascade(
	regclass, meta_columns[]
) RETURNS meta_foreign_keys AS $$
	SELECT meta_foreign_key(
		NULL::text,
		col_names,			-- our columns
		constraint_deferring(),
		$1,				-- the foreign table
		col_names,			-- the foreign columns
		foreign_key_matching(),
		'meta__cascade',	-- ON DELETE CASCADE
		foreign_key_action()
	) FROM meta_cols_name_array($2) col_names
$$ LANGUAGE sql;
COMMENT ON FUNCTION same_forn_keys_cascade(
	regclass, meta_columns[]
) IS
'Turn the array of columns into a foreign key constraint where
the foreign keys and the local keys have the same name
and the ON DELETE action should be CASCADE';

CREATE OR REPLACE
FUNCTION meta_column_text(meta_columns) RETURNS text AS $$
	SELECT ($1).name_::text || ' ' || ($1).type_
	|| CASE WHEN ($1).not_null IS NULL OR NOT ($1).not_null THEN ''
		 ELSE ' NOT NULL'
		 END
	|| alt_text(' DEFAULT ', quote_literal(($1).default_), '', '')
$$ LANGUAGE sql;
COMMENT ON FUNCTION meta_column_text(meta_columns) IS
'returns a textual description of one column of a table';

CREATE OR REPLACE
FUNCTION column_name_array(column_names)
RETURNS column_name_arrays AS $$
	SELECT ARRAY[$1::text]::column_name_arrays
$$ LANGUAGE sql;

CREATE OR REPLACE FUNCTION try_column_forn_key_text(
	column_names, meta_foreign_keys[]
) RETURNS text AS $$
	SELECT alt_text(
		' ', ARRAY(
			SELECT foreign_key_references_text(ref)
			FROM unnest($2) ref
			WHERE from_column_name_array((ref).cols)
				= from_column_name_array(column_name_array($1))
		), ' ', '', ''
	)
$$ LANGUAGE sql;
COMMENT ON FUNCTION try_column_forn_key_text(
	column_names, meta_foreign_keys[]
) IS 'all foreign key references which only link to this column';

CREATE OR REPLACE
FUNCTION meta_column_texts(meta_columns[], meta_tables)
RETURNS text[] AS $$
	SELECT ARRAY(
		SELECT meta_column_text(c)
		|| try_column_checks_text( (c).name_, ($2).checks )
		|| try_column_primary_text( (c).name_, ($2).primary_key )
		|| try_column_unique_text( (c).name_, ($2).uniques )
		|| try_column_forn_key_text( (c).name_, ($2).forn_keys )
		FROM unnest($1) c
	)
$$ LANGUAGE sql;
COMMENT ON FUNCTION meta_column_texts(
	meta_columns[], meta_tables
) IS 'returns a text array of descriptions of the cols of a table';

CREATE OR REPLACE
FUNCTION table_forn_key_texts(meta_foreign_keys[])
RETURNS text[] AS $$
	SELECT ARRAY(
		SELECT foreign_key_text(fk) FROM unnest($1) fk
		WHERE fk.cnst_name IS NOT NULL
		OR array_length( from_column_name_array(fk.cols) ) > 1
	)
$$ LANGUAGE sql;
COMMENT ON FUNCTION table_forn_key_texts(
	meta_foreign_keys[]
) IS 'returns text array declaring all multi-column foreign_keys';

-- ** Handy functions for portions of function bodies

CREATE OR REPLACE
FUNCTION list_args(ANYARRAY, integer = 0) RETURNS text[] AS $$
	SELECT ARRAY(
		SELECT '$' || (i+$2)::text FROM generate_subscripts($1, 1) i
	)
$$ LANGUAGE sql;

CREATE OR REPLACE FUNCTION equate_colnames_args(
	column_name_arrays, text=NULL, integer=0
) RETURNS text[] AS $$
	SELECT ARRAY(
		SELECT x || quote_ident(n) || '=' || '$' || (i+$3)::text
		FROM array_to_set(from_column_name_array($1))
		AS (i integer, n text)
	) FROM COALESCE($2 || '.', '') x
$$ LANGUAGE sql;

CREATE OR REPLACE FUNCTION and_equate_colnames_args(
	column_name_arrays, text=NULL, integer=0
) RETURNS text AS $$
	SELECT array_to_string( equate_colnames_args($1,$2,$3), ' AND ' )
$$ LANGUAGE sql;

CREATE OR REPLACE FUNCTION and_equate_colnames_args(
	column_name_arrays, regclass, integer = 0
) RETURNS text AS $$
	SELECT and_equate_colnames_args($1, $2::text, $3)
$$ LANGUAGE sql;

CREATE OR REPLACE FUNCTION equate_cols_args(
	meta_columns[], text = NULL, integer = 0
) RETURNS text[] AS $$
	SELECT equate_colnames_args(
		meta_cols_name_array($1), $2, $3
	)
$$ LANGUAGE sql;

CREATE OR REPLACE FUNCTION equate_cols_args(
	meta_columns[], regclass, integer = 0
) RETURNS text[] AS $$
	SELECT equate_colnames_args(
		meta_cols_name_array($1), $2::text, $3
	)
$$ LANGUAGE sql;

CREATE OR REPLACE FUNCTION and_equate_cols_args(
	meta_columns[], text = NULL, integer = 0
) RETURNS text AS $$
	SELECT and_equate_colnames_args(
		meta_cols_name_array($1), $2, $3
	)
$$ LANGUAGE sql;

CREATE OR REPLACE FUNCTION and_equate_cols_args(
	meta_columns[], regclass, integer = 0
) RETURNS text AS $$
	SELECT and_equate_colnames_args(
		meta_cols_name_array($1), $2, $3
	)
$$ LANGUAGE sql;

CREATE OR REPLACE
FUNCTION class_field_text(regclass, meta_columns)
RETURNS text AS $$
	SELECT $1::text || '.' || quote_ident(($2).name_)
$$ LANGUAGE SQL;

CREATE OR REPLACE
FUNCTION equate_class_fields(regclass, regclass, meta_columns[])
RETURNS text AS $$
	SELECT array_to_string(
		ARRAY(
			SELECT class_field_text($1, c) || '=' || class_field_text($2, c)
			FROM unnest($3) c
		),
		' AND '
	)
$$ LANGUAGE SQL;

-- ** more function features

CREATE OR REPLACE
FUNCTION try_meta_func_create_text(boolean) RETURNS text AS $$
	SELECT 'CREATE '
		|| CASE WHEN $1 THEN ' OR REPLACE' ELSE '' END
		|| E'\nFUNCTION '
$$ LANGUAGE sql STRICT;

CREATE OR REPLACE
FUNCTION meta_func_create_text(boolean) RETURNS text AS $$
	SELECT non_null(
		try_meta_func_create_text($1),
		'meta_func_create_text(boolean)'
	)
$$ LANGUAGE sql;

CREATE OR REPLACE FUNCTION try_meta_func_returns_text(
	regtype, bool
) RETURNS text AS $$
	SELECT 'RETURNS '
	|| CASE WHEN $2 THEN 'SETOF ' ELSE '' END
	|| COALESCE($1::text, 'void')
$$ LANGUAGE sql STRICT;

CREATE OR REPLACE
FUNCTION meta_func_returns_text(regtype, bool) RETURNS text AS $$
	SELECT non_null(
		try_meta_func_returns_text($1,$2),
		'meta_func_returns_text(regtype,bool)'
	)
$$ LANGUAGE sql;

CREATE OR REPLACE
FUNCTION meta_func_strictness_text(bool) RETURNS text AS $$
	SELECT
	CASE WHEN $1 IS NOT NULL AND $1 THEN ' STRICT' ELSE '' END
$$ LANGUAGE sql IMMUTABLE;


CREATE OR REPLACE
FUNCTION meta_func_stability_text(meta_func_stabilities)
RETURNS text AS $$
	SELECT CASE
		WHEN $1 IS NULL THEN ''
		WHEN $1 = 'meta__volatile' THEN ''
		ELSE enum_syntax($1)
	END
$$ LANGUAGE sql IMMUTABLE;

CREATE OR REPLACE
FUNCTION meta_func_security_text(meta_func_securities)
RETURNS text AS $$
	SELECT CASE
		WHEN $1 IS NULL THEN ''
		WHEN $1 = 'meta__invoker' THEN ''
		ELSE 'SECURITY ' || enum_syntax($1)
	END
$$ LANGUAGE sql IMMUTABLE;

-- this should be a non- try_ function!!
CREATE OR REPLACE
FUNCTION try_func_cost_text(integer) RETURNS text AS $$
	SELECT alt_text(E'\nCOST ', $1::text, E'\n', '')
$$ LANGUAGE sql IMMUTABLE;

-- this should be a try_ function!!
CREATE OR REPLACE
FUNCTION meta_func_rows_text(integer, bool) RETURNS text AS $$
	SELECT E'\nROWS '|| $1::text || E'\n'
	WHERE $2			--  WHERE assert($2)
$$ LANGUAGE sql IMMUTABLE;

-- this should be a non- try_ function!!
CREATE OR REPLACE
FUNCTION try_func_rows_text(integer, bool) RETURNS text AS $$
SELECT alt_text(E'\nROWS ', meta_func_rows_text($1, $2), E'\n', '')
$$ LANGUAGE sql IMMUTABLE;

-- this should be a non- try_ function!!
CREATE OR REPLACE
FUNCTION try_func_set_vars_text(meta_func_set_vars[])
RETURNS text AS $$
	SELECT alt_text(
		'',				-- prefix
		ARRAY(
			SELECT '  SET ' || (vv).var_name
			|| CASE WHEN (vv).var_val IS NULL THEN ''
							WHEN (vv).var_val = 'FROM LOCAL'
				THEN ' FROM LOCAL'
				ELSE ' TO' || quote_literal( (vv).var_val )
				 END
			FROM unnest($1) vv
		),
		E'\n',			-- inbetween elements
		'',				-- suffix
		''				-- alternative if none
	)
$$ LANGUAGE sql;		-- IMMUTABLE

-- What does plpgsql do if extra semicolons wind up following
-- words like DECLARE, BEGIN, EXCEPTION which were treated as
-- statements?
CREATE OR REPLACE FUNCTION try_meta_func_body_text(
	meta_func_bodies
) RETURNS text AS $$
	SELECT quote_literal($1)
$$ LANGUAGE sql STRICT;

CREATE OR REPLACE
FUNCTION meta_func_body_text(meta_func_bodies)
RETURNS text AS $$
	SELECT non_null(
		try_meta_func_body_text($1),
		'meta_func_body_text(meta_func_bodies)'
	)
$$ LANGUAGE sql;		-- IMMUTABLE -- WHY COMMENTED OUT???
COMMENT ON FUNCTION meta_func_body_text(meta_func_bodies) IS
'converts function body text into a function body;
it would be nice to do this for a (molecular) parse tree';

CREATE OR REPLACE
FUNCTION meta_func_linkage_text(text, text) RETURNS text AS $$
	SELECT quote_literal( obj_file )
			 || CASE WHEN $2 IS NULL THEN ''
					ELSE quote_literal( ', ' || $2 )
					END
	FROM non_null($1, 'meta_func_linkage_text(text, text)') obj_file
$$ LANGUAGE sql;		-- IMMUTABLE
COMMENT ON FUNCTION meta_func_linkage_text(text, text) IS
'AS object_file, link_symbol where link_symbol is optional';

-- meta_func_text(meta_funcs)
CREATE OR REPLACE
FUNCTION try_meta_func_text(meta_funcs) RETURNS text AS $$
	SELECT meta_func_create_text( ($1).replace_ )
	|| meta_func_head_text($1, true)
	|| E'\n' || meta_func_returns_text(($1).returns_, ($1).returns_set) 
	|| ' LANGUAGE ' || meta_lang_text( ($1).lang )
	|| meta_func_stability_text( ($1).stability )
	|| meta_func_strictness_text(
		CASE ($1).strict_
			WHEN 'meta__strict' THEN true
			WHEN 'meta__non_strict' THEN false
			WHEN 'meta__auto_strict' THEN ($1).name_ LIKE 'try_%'
			ELSE debug_fail(
				'try_meta_func_text(meta_funcs)', false, 'illegal strictness'
			)
		END
	)
	|| meta_func_security_text( ($1).security_ )
	|| try_func_cost_text( ($1).cost_ )
	|| try_func_rows_text( ($1).rows_, ($1).returns_set )
	|| try_func_set_vars_text( ($1).set_vars )
	|| E' AS\n'
	|| CASE WHEN ($1).body IS NOT NULL
		THEN regexp_replace( regexp_replace(
				meta_func_body_text( ($1).body ),
				'-->this-proc-sig<--',
				meta_func_head_text($1, false),
				'g'
			),
			'-->this-proc-returns<--',
			meta_func_returns_text(($1).returns_, ($1).returns_set),
			'g'
		) ELSE meta_func_linkage_text( ($1).obj_file, ($1).link_symbol )
		END
	|| E';\n'
$$ LANGUAGE sql STRICT;

CREATE OR REPLACE
FUNCTION meta_func_text(meta_funcs) RETURNS text AS $$
	SELECT non_null(
		try_meta_func_text($1),
		'meta_func_text(meta_funcs)'
	)
$$ LANGUAGE sql;
COMMENT ON FUNCTION meta_func_text(meta_funcs) IS
'turns a description of a function into text which would define that
function';

CREATE OR REPLACE FUNCTION try_meta_func_body(
	VARIADIC text[]
) RETURNS meta_func_bodies AS $$
	SELECT (
		E'\n\t' || array_to_string($1, E';\n\t') || E'\n'
	)::meta_func_bodies
$$ LANGUAGE sql IMMUTABLE STRICT;

CREATE OR REPLACE FUNCTION meta_func_body(
	VARIADIC text[]
) RETURNS meta_func_bodies AS $$
	SELECT non_null(
		try_meta_func_body(VARIADIC $1),
		'meta_func_body(text[])'
	)
$$ LANGUAGE sql IMMUTABLE;


CREATE OR REPLACE FUNCTION trial_meta_func_row(
	_name text,
	_lang meta_langs,
	_replace boolean,
	_args meta_args[],
	_returns regtype,
	_returns_set bool,
	_stability meta_func_stabilities,
	_strict meta_func_stricts,
	_security meta_func_securities,
	_cost integer,
	_rows integer,
	_set_vars meta_func_set_vars[],
	_body meta_func_bodies,
	_obj_file text,
	_link_symbol text,
	_ text	-- comment
) RETURNS meta_funcs AS $$
	SELECT ROW(
		_replace,
		_name,
		_args,
		_returns,
		_returns_set,
		_lang,
		_stability,
		_strict,
		_security,
		_cost,
		_rows,
		_set_vars,
		_body,
		_obj_file,
		_link_symbol,
		_	-- comment_
	)::meta_funcs
$$ LANGUAGE sql IMMUTABLE;

COMMENT ON FUNCTION trial_meta_func_row(
	_name text,
	_lang meta_langs,
	_replace boolean,
	_args meta_args[],
	_returns regtype,
	_returns_set bool,
	_stability meta_func_stabilities,
	_strict meta_func_stricts,
	_security meta_func_securities,
	_cost integer,
	_rows integer,
	_set_vars meta_func_set_vars[],
	_body meta_func_bodies,
	_obj_file text,
	_link_symbol text,
	_ text
) IS 'not to be called directly -
	the result may not be a valid meta_funcs row!
';

CREATE OR REPLACE
FUNCTION bad_meta_func(meta_funcs, regprocedure)
RETURNS meta_funcs AS $$
DECLARE
	ret meta_funcs;
BEGIN
	SELECT INTO ret debug_fail($2, $1, CASE
		WHEN ($1).name_ IS NULL THEN 'function name is NULL'
		WHEN ($1).lang_ IS NULL THEN 'function language is NULL'
		WHEN ($1).body IS NULL AND ($1).obj_file IS NULL THEN
			'either a body or link file required'
		WHEN ($1).body IS NOT NULL AND ($1).obj_file IS NOT NULL THEN
			'only a body or link file, not both '
		WHEN ($1).obj_file IS NULL AND ($1).link_symbol IS NOT NULL THEN
			'a link symbol requires an object file'
		ELSE '--> report "impossible" error <--'	
		END
	);
	RETURN ret;
END
$$ LANGUAGE plpgsql IMMUTABLE;

CREATE OR REPLACE
FUNCTION ok_meta_func(meta_funcs) RETURNS boolean AS $$
	SELECT
		($1).name_ IS NOT NULL AND ($1).lang IS NOT NULL  AND
		(($1).body IS NULL) <> (($1).obj_file IS NULL) AND
		NOT ( ($1).obj_file IS NULL AND ($1).link_symbol IS NOT NULL )
$$ LANGUAGE sql IMMUTABLE;

CREATE OR REPLACE FUNCTION like_meta_func_row(
	_base meta_funcs,
	_name text = NULL,
	_lang meta_langs = NULL,
	_replace boolean = NULL,
	_args meta_args[] = NULL,
	_returns regtype = NULL,
	_returns_set bool = NULL,
	_stability meta_func_stabilities = NULL,
	_strict meta_func_stricts = NULL,
	_security meta_func_securities = NULL,
	_cost integer = NULL,
	_rows integer = NULL,
	_set_vars meta_func_set_vars[] = NULL,
	_body meta_func_bodies = NULL,
	_obj_file text = NULL,
	_link_symbol text = NULL,
	_ text = NULL
) RETURNS meta_funcs AS $$
	SELECT tuple
	FROM trial_meta_func_row(
		COALESCE( _name, $1.name_ ),
		COALESCE( _lang, $1.lang ),
		COALESCE( _replace, $1.replace_ ),
		COALESCE( _args, $1.args ),
		COALESCE( _returns, $1.returns_ ),
		COALESCE( _returns_set, $1.returns_set ),
		COALESCE( _stability, $1.stability ),
		COALESCE( _strict, $1.strict_ ),
		COALESCE( _security, $1.security_ ),
		COALESCE( _cost, $1.cost_ ),
		COALESCE( _rows, $1.rows_ ),
		COALESCE( _set_vars, $1.set_vars ),
		COALESCE( _body, $1.body ),
		NULLIF( COALESCE( _obj_file, $1.obj_file ), '' ),
		NULLIF( COALESCE( _link_symbol, $1.link_symbol ), '' ),
		COALESCE( _, $1.comment_ )
	) tuple WHERE ok_meta_func(tuple)
$$ LANGUAGE sql IMMUTABLE;

CREATE OR REPLACE FUNCTION try_meta_func_row(
	_name text,
	_lang meta_langs = 'meta__sql',
	_replace boolean = true,
	_args meta_args[] = '{}',
	_returns regtype = 'void',
	_returns_set bool = false,
	_stability meta_func_stabilities = meta_func_stability() ,
	_strict meta_func_stricts = meta_func_strict(),
	_security meta_func_securities = meta_func_security(),
	_cost integer = NULL,
	_rows integer = NULL,
	_set_vars meta_func_set_vars[] = '{}',
	_body meta_func_bodies = NULL,
	_obj_file text = NULL,
	_link_symbol text = NULL,
	_ text = ''
) RETURNS meta_funcs AS $$
	SELECT tuple
	FROM trial_meta_func_row(
			_name,
			_lang,
			_replace,
			_args,
			_returns,
			_returns_set,
			_stability,
			_strict,
			_security,
			_cost,
			_rows,
			_set_vars,
			_body,
			_obj_file,
			_link_symbol,
			_
	) tuple WHERE ok_meta_func(tuple)
$$ LANGUAGE sql IMMUTABLE;

CREATE OR REPLACE FUNCTION meta_func_row(
	_name text,
	_lang meta_langs = 'meta__sql',
	_replace boolean = true,
	_args meta_args[] = '{}',
	_returns regtype = 'void',
	_returns_set bool = false,
	_stability meta_func_stabilities = meta_func_stability(),
	_strict meta_func_stricts = meta_func_strict(),
	_security meta_func_securities = meta_func_security(),
	_cost integer = NULL,
	_rows integer = NULL,
	_set_vars meta_func_set_vars[] = '{}',
	_body meta_func_bodies = NULL,
	_obj_file text = NULL,
	_link_symbol text = NULL,
	_ text = ''
) RETURNS meta_funcs AS $$
	SELECT CASE
		WHEN ok_meta_func(tuple) THEN tuple
		ELSE bad_meta_func(
			tuple, 'meta_func_row(
			text,meta_langs,boolean,meta_args[],regtype,bool,
			meta_func_stabilities, meta_func_stricts, meta_func_securities,
			integer, integer, meta_func_set_vars[],
			meta_func_bodies, text, text, text
		)'  )
	END FROM trial_meta_func_row(
			_name,
			_lang,
			_replace,
			_args,
			_returns,
			_returns_set,
			_stability,
			_strict,
			_security,
			_cost,
			_rows,
			_set_vars,
			_body,
			_obj_file,
			_link_symbol,
			_
	) tuple
$$ LANGUAGE sql IMMUTABLE;
COMMENT ON FUNCTION meta_func_row(
	text, meta_langs, boolean,
	meta_args[], regtype,bool,
	meta_func_stabilities, meta_func_stricts, meta_func_securities,
	integer, integer, meta_func_set_vars[],
	meta_func_bodies, text, text, text
) IS 'construct a meta_funcs row';

CREATE OR REPLACE FUNCTION try_meta_sql_func(
	_name text,
	_body meta_func_bodies,
	_replace boolean = true,
	_args meta_args[] = '{}',
	_returns regtype = 'void',
	_returns_set bool = false,
	_stability meta_func_stabilities = meta_func_stability() ,
	_strict meta_func_stricts = meta_func_strict(),
	_security meta_func_securities = meta_func_security(),
	_cost integer = NULL,
	_rows integer = NULL,
	_set_vars meta_func_set_vars[] = '{}',
	_ text = ''
) RETURNS meta_funcs AS $$
	SELECT try_meta_func_row(
		_name := _name,
		_body := _body,
		_replace := _replace,
		_args := _args,
		_returns := _returns,
		_returns_set := _returns_set,
		_lang := 'meta__sql',
		_stability := _stability,
		_strict := _strict,
		_security := _security,
		_cost := _cost,
		_rows := _rows,
		_set_vars := _set_vars,
		_ := _
	)
$$ LANGUAGE sql; -- Can't be STRICT because of defaults;

CREATE OR REPLACE FUNCTION meta_sql_func(
	_name text,
	_body meta_func_bodies,
	_replace boolean = true,
	_args meta_args[] = '{}',
	_returns regtype = 'void',
	_returns_set bool = false,
	_stability meta_func_stabilities = meta_func_stability(),
	_strict meta_func_stricts = meta_func_strict(),
	_security meta_func_securities = meta_func_security(),
	_cost integer = NULL,
	_rows integer = NULL,
	_set_vars meta_func_set_vars[] = '{}',
	_ text = ''
) RETURNS meta_funcs AS $$
	SELECT non_null(
		try_meta_sql_func(
			_name,
			_body,
			_replace,
			_args,
			_returns,
			_returns_set,
			_stability,
			_strict,
			_security,
			_cost,
			_rows,
			_set_vars,
			_
		),
		'meta_sql_func(
		text,meta_func_bodies,boolean,meta_args[],regtype,bool,
		meta_func_stabilities,meta_func_stricts,meta_func_securities,
		integer,integer,meta_func_set_vars[], text)'
	)
$$ LANGUAGE sql;
COMMENT ON FUNCTION meta_sql_func(
	text, meta_func_bodies, boolean,
	meta_args[], regtype, bool,
	meta_func_stabilities, meta_func_stricts, meta_func_securities,
	integer, integer, meta_func_set_vars[], text
) IS 'construct a meta_funcs row for an sql function';

CREATE OR REPLACE FUNCTION meta_obj_func(
	_name text,
	_lang meta_langs,
	_obj_file text,
	_link_symbol text = NULL,
	_replace boolean = true,
	_args meta_args[] = '{}',
	_returns regtype = 'void',
	_returns_set bool = false,
	_stability meta_func_stabilities = meta_func_stability(),
	_strict meta_func_stricts = meta_func_strict(),
	_security meta_func_securities = meta_func_security(),
	_cost integer = NULL,
	_rows integer = NULL,
	_set_vars meta_func_set_vars[] = '{}',
	_ text = ''
) RETURNS meta_funcs AS $$
	SELECT meta_func_row(
		_name := _name,
		_lang := _lang,
		_obj_file := _obj_file,
		_link_symbol := _link_symbol,
		_replace := _replace,
		_args := _args,
		_returns := _returns,
		_returns_set := _returns_set,
		_stability := _stability,
		_strict := _strict,
		_security := _security,
		_cost := _cost,
		_rows := _rows,
		_set_vars := _set_vars,
		_ := _
	)
$$ LANGUAGE sql;
COMMENT ON FUNCTION meta_obj_func(
	text, meta_langs, text, text,
	boolean, meta_args[], regtype, bool,
	meta_func_stabilities, meta_func_stricts, meta_func_securities,
	integer, integer, meta_func_set_vars[], text
) IS 'Construct a meta_funcs row for an external function';

CREATE OR REPLACE
FUNCTION func_comment_text(regprocedure, meta_args[], text)
RETURNS text AS $$
	SELECT comment_text('meta__function', $1::text,
		func_head_comment_text($1, $2)
		|| CASE
			 WHEN $3 IS NOT NULL AND $3 != '' THEN ': ' || $3
			 ELSE ''
			 END
	)
$$ LANGUAGE sql;
COMMENT ON
FUNCTION func_comment_text(regprocedure, meta_args[], text) IS
'returns text for creating a comment starting with the function and
argument names';

CREATE OR REPLACE FUNCTION create_func_comment(
	func regprocedure,
	args meta_args[],
	comment_ text
) RETURNS regprocedure AS $$
	SELECT $1 FROM meta_execute(
		'create_func_comment(regprocedure, meta_args[], text)',
		func_comment_text($1, $2, $3)
	)
$$ LANGUAGE sql;

SELECT create_func_comment(
	'create_func_comment(regprocedure, meta_args[], text)',
	ARRAY[
		 meta_arg('regprocedure', 'func'),
		 meta_arg('meta_args[]', 'args'),
		 meta_arg('text', 'comment')
	 ],
'creating a comment starting with the function and argument names'
);

CREATE OR REPLACE
FUNCTION create_func_(meta_funcs) RETURNS regprocedure AS $$
DECLARE
	_head TEXT := meta_func_head_text($1, false);
	_create TEXT := meta_func_text($1);
	_func regprocedure;
	this regprocedure := 'create_func_(meta_funcs)';
	func_result boolean;
	comment_result boolean;
BEGIN
	IF NOT ($1).replace_ THEN
		PERFORM drop_entity('meta__function', _head);
	END IF;
	func_result := meta_execute(this, _create);
	_func := non_null(meta_procedure_oid(_head), this, _head);
	IF COALESCE( ($1).comment_, '' ) <> '' THEN
		comment_result := meta_execute(
			this, func_comment_text(_func, ($1).args, ($1).comment_)
		);
	END IF;
	RETURN _func;
END
$$ LANGUAGE plpgsql;
COMMENT ON FUNCTION create_func_(meta_funcs) IS
'create the described function and a comment on it; return its oid;
TO DO: Add any comments on the arguments!!';

CREATE OR REPLACE
FUNCTION prefix_try_func_name_text(text) RETURNS text AS $$
	SELECT regexp_replace($1, '^([^.]+\.)?(find_)?(.*)', '\1try_\3')
$$ LANGUAGE sql;

COMMENT ON FUNCTION prefix_try_func_name_text(text) IS '
	Return a new name for a "try_" version of the function.
	Leaves any schema prefix alone.  Strips off any find_ prefix.
';

CREATE OR REPLACE
FUNCTION prefix_try_func_name(meta_funcs) RETURNS text AS $$
	SELECT prefix_try_func_name_text( ($1).name_ )
$$ LANGUAGE sql;

COMMENT ON FUNCTION prefix_try_func_name(meta_funcs) IS '
	Return a new name for a "try_" version of the function.
	See prefix_try_func_name_text for the policy.
';

CREATE OR REPLACE
FUNCTION try_create_two_funcs(meta_funcs, text)
RETURNS regprocedure AS $$
	SELECT create_func_( like_meta_func_row(
		$1, _lang := 'meta__sql', _strict := 'meta__non_strict',
		_body := 'SELECT non_null('
			|| $2 || list_texts( list_args( ($1).args ) )
			|| ',' || 	quote_literal(meta_func_head_text($1, false))
		|| ')', _obj_file := '', _link_symbol := ''
	) ) FROM create_func_( like_meta_func_row(
		$1, _name := $2, _strict := 'meta__strict'
	) ) try_func WHERE try_func IS NOT NULL
$$ LANGUAGE sql STRICT;

CREATE OR REPLACE
FUNCTION try_create_func(meta_funcs)
RETURNS regprocedure AS $$
	SELECT CASE ($1).strict_
		WHEN 'meta__strict2' THEN
			try_create_two_funcs( $1, prefix_try_func_name($1) )
		ELSE create_func_($1)
	END
$$ LANGUAGE sql STRICT;

CREATE OR REPLACE
FUNCTION create_func(meta_funcs) RETURNS regprocedure AS $$
	SELECT non_null(
		try_create_func($1), 'create_func(meta_funcs)'
	)
$$ LANGUAGE sql;

COMMENT ON FUNCTION create_func(meta_funcs)
IS 'If the strictness is NOT meta__strict2 simply pass
the argument to create_func_.  Otherwise, generate
a pair of strict and non-strict functions based on the
given meta_funcs instsance';

CREATE OR REPLACE FUNCTION create_func(
	_name text,
	_body meta_func_bodies,
	_lang meta_langs = 'meta__sql',
	_replace boolean = true,
	_args meta_args[] = '{}',
	_returns regtype = 'void',
	_returns_set bool = false,
	_stability meta_func_stabilities = meta_func_stability(),
	_strict meta_func_stricts = meta_func_strict(),
	_security meta_func_securities = meta_func_security(),
	_cost integer = NULL,
	_rows integer = NULL,
	_set_vars meta_func_set_vars[] = '{}',
	_ text = '',
	_by regprocedure = 'create_func(meta_funcs)'
) RETURNS regprocedure AS $$
	SELECT create_func( meta_func_row(
		_name := _name,
		_lang := _lang,
		_body := _body,
		_replace := _replace,
		_args := _args,
		_returns := _returns,
		_returns_set := _returns_set,
		_stability := _stability,
		_strict := _strict,
		_security := _security,
		_cost := _cost,
		_rows := _rows,
		_set_vars := _set_vars,
		_ := str_str_delim(_, 'by ' || _by)
	) )
$$ LANGUAGE sql IMMUTABLE;
COMMENT ON FUNCTION create_func(
	text, meta_func_bodies, meta_langs,
	boolean, meta_args[], regtype, bool,
	meta_func_stabilities, meta_func_stricts, meta_func_securities,
	integer, integer, meta_func_set_vars[], text, regprocedure
) IS 'CREATE & COMMENT ON described FUNCTION';

CREATE OR REPLACE FUNCTION create_obj_func(
	_name text,
	_lang meta_langs,
	_obj_file text,
	_link_symbol text = NULL,
	_replace boolean = true,
	_args meta_args[] = '{}',
	_returns regtype = 'void',
	_returns_set bool = false,
	_stability meta_func_stabilities = meta_func_stability(),
	_strict meta_func_stricts = meta_func_strict(),
	_security meta_func_securities = meta_func_security(),
	_cost integer = NULL,
	_rows integer = NULL,
	_set_vars meta_func_set_vars[] = '{}',
	_ text = NULL
) RETURNS regprocedure AS $$
	SELECT create_func( meta_func_row(
		_name := _name,
		_lang := _lang,
		_obj_file := _obj_file,
		_link_symbol := _link_symbol,
		_replace := _replace,
		_args := _args,
		_returns := _returns,
		_returns_set := _returns_set,
		_stability := _stability,
		_strict := _strict,
		_security := _security,
		_cost := _cost,
		_rows := _rows,
		_set_vars := _set_vars,
		_ := _
	) )
$$ LANGUAGE sql;
COMMENT ON FUNCTION create_obj_func(
	text, meta_langs, text, text,
	boolean, meta_args[], regtype, bool,
	meta_func_stabilities, meta_func_stricts, meta_func_securities,
	integer, integer, meta_func_set_vars[], text
) IS 'CREATE & COMMENT ON linkage to external function';

-- ** meta_composite_type

CREATE OR REPLACE FUNCTION meta_composite_type(
	text,				-- name_
	meta_columns[],		-- cols
	text				-- comment
) RETURNS meta_composite_types AS $$
	SELECT ($1,$2,$3)::meta_composite_types
$$ LANGUAGE sql;
COMMENT ON FUNCTION meta_composite_type(
	text, meta_columns[], text
) IS '(name_, cols, comment_) -> meta_tables row';

CREATE OR REPLACE
FUNCTION meta_composite_type_text(meta_tables)
RETURNS text AS $$
	SELECT 'CREATE TYPE '
	|| ($1).name_
	|| E'AS (\n\t'
	|| array_to_string(
			meta_column_texts( ($1).cols, $1 )
			|| table_check_constraint_texts( ($1).checks )
			|| table_primary_key_texts( ($1).primary_key )
			|| table_unique_constraint_texts( ($1).uniques )
			|| table_forn_key_texts( ($1).forn_keys )
		, E',\n\t'
		)
	|| E');\n'
$$ LANGUAGE sql;

CREATE OR REPLACE
FUNCTION create_composite_type(meta_composite_types)
RETURNS regclass AS $$
DECLARE
	the_typeoid regtype;
	this regprocedure := 'create_composite_type(meta_composite_types)';
	type_result boolean;
	comment_result boolean;
BEGIN
	PERFORM drop_entity('meta__type', ($1).name_);
	type_result := meta_execute(this, meta_composite_type_text($1));
	the_typeoid := non_null(meta_type_oid(($1).name_, this, ($1).name), this);
	IF ($1).comment_ IS NOT NULL THEN
		comment_result := meta_execute(this, create_type_comment(the_typeoid, ($1).comment_));
	END IF;
	RETURN the_typeoid;
END
$$ LANGUAGE plpgsql;

-- ** meta_table

CREATE OR REPLACE FUNCTION meta_table(
	_name text,
	_cols meta_columns[],
	_checks check_constraints[] = '{}',
	_primary index_constraints = NULL,
	_uniques index_constraints[] = '{}',
	_forns meta_foreign_keys[] = '{}',
	_inherits regclass[] = '{}',
	_oids boolean = false,
	_temp meta_temp_tables = 'meta__not_temp_table',
	_space maybe_table_spaces = NULL,
	_withs storage_vars_vals[] = '{}',
	_ text = ''	-- comment
) RETURNS meta_tables AS $$
	SELECT ROW(
		_name,
		_cols,
		_,				-- comment
		_checks,
		_primary,
		_uniques,
		_forns,
		_inherits,
		_oids,
		_temp,
		_space,
		_withs
	)::meta_tables
$$ LANGUAGE sql;
COMMENT ON FUNCTION meta_table(
	text, meta_columns[], check_constraints[], index_constraints,
	index_constraints[], meta_foreign_keys[], regclass[], boolean,
	meta_temp_tables, maybe_table_spaces, storage_vars_vals[], text
) IS '(
	name_, cols, checks, primary_key, uniques, forn_keys,
	inherits_, with_oids, temp_, space_, withs, comment_
) -> meta_tables row';

-- ** create_table

CREATE OR REPLACE
FUNCTION try_inherits_text(regclass[]) RETURNS text AS $$
	SELECT alt_text(
		'INHERITS (',
		ARRAY( SELECT x::text FROM unnest($1) x ),
		', ',
		')',
		''
	)
$$ LANGUAGE sql;

CREATE OR REPLACE
FUNCTION try_on_commit_text(meta_temp_tables)
RETURNS text AS $$
	SELECT COALESCE(
		' ON COMMIT ' || CASE $1
			WHEN 'meta__not_temp_table' THEN NULL
			WHEN 'meta__preserve_rows' THEN 'PRESERVE ROWS'
			WHEN 'meta__delete_rows' THEN 'DELETE ROWS'
			WHEN 'meta__drop' THEN 'DROP'
		END,
		''
	)
$$ LANGUAGE sql;

CREATE OR REPLACE
FUNCTION meta_table_text(meta_tables) RETURNS text AS $$
	SELECT 'CREATE'
	|| CASE
		WHEN ($1).temp_ = 'meta__not_temp_table'
		THEN ''
		ELSE ' TEMP'
		END
	|| ' TABLE '
	|| ($1).name_
	|| E' (\n\t'
	|| array_to_string(
			meta_column_texts( ($1).cols, $1 )
			|| table_check_constraint_texts( ($1).checks )
			|| table_primary_key_texts( ($1).primary_key )
			|| table_unique_constraint_texts( ($1).uniques )
			|| table_forn_key_texts( ($1).forn_keys )
		, E',\n\t'
		)
	|| E'\n)'
	|| try_inherits_text( ($1).inherits_ )
	|| CASE WHEN ($1).with_oids THEN ' WITH OIDS' ELSE '' END
	|| try_on_commit_text( ($1).temp_ )
	|| E';\n'
$$ LANGUAGE sql;

CREATE OR REPLACE
FUNCTION comment_meta_column(regclass, meta_columns)
RETURNS text AS $$
	SELECT CASE WHEN ($2).comment_ IS NOT NULL
		THEN comment_column($1, ($2).name_::text, ($2).comment_)
		ELSE $1::text || '.' || ($2).name_
	END
$$ LANGUAGE sql;

CREATE OR REPLACE
FUNCTION create_table(meta_tables) RETURNS regclass AS $$
DECLARE
	table_text TEXT := meta_table_text($1);
	the_tableoid regclass;
	this regprocedure := 'create_table(meta_tables)';
	_result boolean;
	x meta_columns;
BEGIN
	PERFORM drop_entity('meta__table', ($1).name_);
	_result := meta_execute(this, table_text);
	the_tableoid := non_null( meta_class_oid( ($1).name_ ), this );
	IF ($1).comment_ IS NOT NULL THEN
	 PERFORM create_table_comment(the_tableoid, ($1).comment_);
	END IF;
	FOREACH x IN ARRAY ($1).cols LOOP
		PERFORM comment_meta_column(the_tableoid, x);
	END LOOP;
	RETURN the_tableoid;
END
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION create_table(
	_name text,
	_cols meta_columns[] = '{}',
	_checks check_constraints[] = '{}',
	_primary index_constraints = NULL,
	_uniques index_constraints[] = '{}',
	_forns meta_foreign_keys[] = '{}',
	_inherits regclass[] = '{}',
	_oids boolean = false,
	_temp meta_temp_tables = 'meta__not_temp_table',
	_space maybe_table_spaces = NULL,
	_withs storage_vars_vals[] = '{}',
	_ text = '',										-- comment
	_by regprocedure = 'create_table(meta_tables)'
) RETURNS regclass AS $$
	SELECT create_table(
		meta_table(
			_name, _cols, _checks, _primary, _uniques,
			_forns, _inherits, _oids, _temp, _space, _withs,
			_ || ' - generated by ' || _by
		)
	)
$$ LANGUAGE sql;
COMMENT ON FUNCTION create_table(
	text, meta_columns[], check_constraints[], index_constraints,
	index_constraints[], meta_foreign_keys[], regclass[], boolean,
	meta_temp_tables, maybe_table_spaces, storage_vars_vals[],
	text, regprocedure
) IS 'create the table, return its regclass';

-- * triggers

CREATE OR REPLACE FUNCTION meta_trigger(
	_name name,
	_table regclass,
	_type meta_trigger_types,
	_on meta_trigger_ons[],
	_proc regprocedure,
	_constraint boolean = false,
	_cols text[] =  '{}',
	_from regclass = NULL,
	_deferrable boolean = false,
	_initially_deferred boolean = false,
	_per_row boolean = false,
	_when text = NULL,
	_args text[] = NULL,
	_ text = NULL 								-- comment
) RETURNS meta_triggers AS $$
	SELECT ROW(
		_,													-- comment
		_name,
		_table,
		_type, _constraint, _on,
		COALESCE(_cols, '{}'), _from,
		COALESCE(_deferrable, false),
		COALESCE(_initially_deferred, false),
		COALESCE(_per_row, false),
		_when, _proc, _args
	)::meta_triggers
	FROM
		array_length(_cols) n_cols,
		this(
			'meta_trigger(
				name, regclass,
				meta_trigger_types, meta_trigger_ons[],
				regprocedure, boolean,
				text[], regclass,
				boolean, boolean, boolean,
				text, text[], text
			)'
		)
	WHERE debug_assert( this,
		_name IS NOT NULL, true, 'NULL name'
	) AND debug_assert( this,
		_table IS NOT NULL, true, 'NULL table'
	) AND debug_assert( this,
		is_class(_table, 'rv'), true,
		_table::text, 'not table or view'
	) AND debug_assert( this,
		_type IS NOT NULL, true, 'NULL type'
	) AND debug_assert( this,
		_constraint IS NOT NULL, true,
		'NULL constraint'
	) AND debug_assert( this,
		NOT _constraint OR _type='trigger__after',
		true, 'constraint', _type::text
	) AND debug_assert( this,
		_on IS NOT NULL, true, 'NULL on'
	) AND debug_assert( this,
		valid_trigger_on(_on), true,
		'invalid on', _on::text
	) AND debug_assert( this,
		n_cols=0 OR
		_on=meta_trigger_on('trigger__update_of'),
		true, 'no cols', _on::text
	) AND debug_assert( this,
		n_cols=0 OR _type!='trigger__instead_of',
		true, 'no cols', _type::text
	) AND debug_assert( this,
		_from IS NULL or _constraint, true,
		'from & NOT constraint', _from::text
	) AND debug_assert( this,
		NOT _constraint OR NOT _deferrable, true,
		'constraint & deferrable'
	) AND debug_assert( this,
		NOT _constraint OR _per_row, true,
		'constraint & !per_row'
	) AND debug_assert( this,
		_when IS NULL OR _type!='trigger__instead_of',
		true, 'when', _when::text, _type::text
	) AND debug_assert( this,
		_proc IS NOT NULL, true, 'NULL proc'
	) AND debug_assert( this,
		valid_trigger_proc(_proc, array_length(_args)),
		true, _proc::regprocedure::text
	)
$$ LANGUAGE sql;

CREATE OR REPLACE
FUNCTION meta_trigger_text(meta_triggers) RETURNS text AS $$
	SELECT 'CREATE ' ||
	CASE WHEN ($1).constraint_ THEN 'CONSTRAINT ' ELSE '' END ||
	'TRIGGER ' || ($1).name_ || E'\n' ||
	enum_text( ($1).type_ ) || ' ' ||
	array_to_string( ARRAY(
		SELECT enum_text(unnest) FROM unnest( ($1).on_ )
	), ' OR ' ) ||
	' ON ' || ($1).table_ || E'\n' ||
	COALESCE('FROM ' || ($1).from_ || E'\n', '') ||
	CASE WHEN ($1).deferrable_ THEN E'DEFERRABLE\n' ELSE '' END ||
	CASE WHEN ($1).initially_deferred_
	THEN E'INITIALLY DEFERRED\n' ELSE '' END ||
	'FOR EACH ' ||
	CASE WHEN ($1).per_row_ THEN 'ROW' ELSE 'STATEMENT' END ||
	E'\n' ||
	COALESCE('WHEN( ' || ($1).when_ || E' )\n', '') ||
	'EXECUTE PROCEDURE ' || ($1).proc_::regproc ||
	COALESCE('( ' || array_to_string( ($1).args_, ', ' ) || ' ), ', '')
$$ LANGUAGE sql;

CREATE OR REPLACE FUNCTION exists_trigger(meta_triggers)
RETURNS boolean AS $$
	SELECT exists(
		SELECT oid FROM pg_trigger
		WHERE tgname = ($1).name_ AND tgrelid = ($1).table_
	)
$$ LANGUAGE sql;

CREATE OR REPLACE FUNCTION drop_trigger_if_exists(meta_triggers)
RETURNS boolean AS $$
	SELECT CASE WHEN exists_trigger THEN meta_execute(this,
		'DROP TRIGGER', ($1).name_::text,
		'ON', ($1).table_::text, 'CASCADE'
	) ELSE false END FROM
		exists_trigger($1),
		this( 'drop_trigger_if_exists(meta_triggers)' )
$$ LANGUAGE sql;

CREATE OR REPLACE FUNCTION trigger_comment_text(
	meta_triggers, 	_by regprocedure = NULL
) RETURNS text AS $$
	SELECT E'\nCOMMENT ON TRIGGER ' ||
	($1).name_ || ' ON ' || ($1).table_ ||
	E' IS\n' || quote_literal( _comment )
	FROM NULLIF(
		str_str_delim( ($1).comment_, 'by ' || _by ),		''
	) _comment
$$ LANGUAGE sql STRICT IMMUTABLE;

CREATE OR REPLACE FUNCTION create_trigger_(
	meta_triggers, _no_drop_ boolean, _by regprocedure
) RETURNS oid AS $$
	SELECT CASE WHEN NOT _no_drop_
		THEN drop_trigger_if_exists($1)
	END;
	SELECT meta_execute( _by, meta_trigger_text($1) );
	SELECT CASE WHEN _comment IS NOT NULL
		THEN meta_execute( _by, _comment )
	END FROM trigger_comment_text($1, _by) _comment;
	SELECT oid FROM pg_trigger
	WHERE tgname = ($1).name_ AND tgrelid = ($1).table_
$$ LANGUAGE sql;

CREATE OR REPLACE FUNCTION create_trigger(
	meta_triggers, _no_drop_ boolean = false,
	_by regprocedure = NULL
) RETURNS oid AS $$
	SELECT create_trigger_( $1, $2, COALESCE(_by,
		'create_trigger(meta_triggers, boolean, regprocedure)'
	) )
$$ LANGUAGE sql;
